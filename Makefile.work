###############################################################################
## Wrapper for starting make inside sonic-slave container
#
#  Supported parameters:
#
#  * PLATFORM: Specific platform we wish to build images for.
#  * BUILD_NUMBER: Desired version-number to pass to the building-system.
#  * EXT_BUILD_TIMESTAMP: Externally-supplied timestamp used by build process instead of querying date/time.
#  * ENABLE_DHCP_GRAPH_SERVICE: Enables get-graph service to fetch minigraph files
#    through http.
#  * ENABLE_ZTP: Enables zero touch provisioning.
#  * SHUTDOWN_BGP_ON_START: Sets admin-down state for all bgp peerings after restart.
#  * ENABLE_PFCWD_ON_START: Enable PFC Watchdog (PFCWD) on server-facing ports
#  * by default for TOR switch.
#  * ENABLE_SYNCD_RPC: Enables rpc-based syncd builds.
#  * INSTALL_DEBUG_TOOLS: Install debug tools and debug symbol packages.
#  * SONIC_DEBUGGING_ON: Include debug symbols in Debian packages.
#  * SONIC_PROFILING_ON: Include debug symbols and disable code optimizations in Debian packages.
#  * SONIC_COVERAGE_ON: Build using code coverage flags and generate coverage data during compilation.
#  * USERNAME: Desired username -- default at rules/config
#  * PASSWORD: Desired password -- default at rules/config
#  * KEEP_SLAVE_ON: Keeps slave container up and active after building process concludes.
#  *                Note that rm=true is still set, so once user quits from the docker
#  *                           session, the docker will be removed.
#  *                Please note that with current Stretch build structure,
#  *                user of KEEP_SLAVE_ON feature will have to be conscious
#  *                about which docker to stay inside after build is done.
#  *                - If user desires to stay inside Jessie docker, please issue
#  *                  make KEEP_SLAVE_ON=yes jessie
#  *                - If user desires to stay inside Stretch docker, please issue
#  *                  make NOJESSIE=1 KEEP_SLAVE_ON=yes <any target>
#  * SOURCE_FOLDER: host path to be mount as /var/$(USER)/src, only effective when KEEP_SLAVE_ON=yes
#  * SONIC_BUILD_JOBS: Specifying number of concurrent build job(s) to run
#  * SONIC_MAKE_JOBS: Specifying number of parallel processes to run within a target makefile
#  * VS_PREPARE_MEM: Prepare memory in VS build (drop cache and compact).
#  *                 Default: yes
#  *                 Values:  yes, no
#  * KERNEL_PROCURE_METHOD: Specifying method of obtaining kernel Debian package: download, cache, or build
#  * KERNEL_CACHE_PATH: Full path to kernel Debian package tarball when cache procure method is used
#  * SONIC_DPKG_CACHE_METHOD: Specifying method of obtaining the Debian packages from cache: none or cache
#  * SONIC_DPKG_CACHE_SOURCE: Debian package cache location when cache enabled for debian packages
#  * LOCAL_SAI_DEBS_PATH: Full path to the parent directory that holds SAI debian packages
#  * BUILD_PRODUCT: Optional SONiC product identifier for the image we wish to build
#
###############################################################################

SHELL = /bin/bash

USER := $(shell id -un)
PWD := $(shell pwd)
BASE_IMAGE_LOCK_TIMEOUT_SECS = 3600
USER_IMAGE_LOCK_TIMEOUT_SECS = 900
LOCK_DIR = /tmp/docker_images_locks

ifeq ($(USER), root)
$(error Add your user account to docker group and use your user account to make. root or sudo are not supported!)
endif

# Check for minimum Docker version on build host
# Note: Using the greater of CE (17.05.0) and EE (17.06.1) versions that support ARG before FROM
docker_min := 17.06.1
docker_min_ver := $(shell echo "$(docker_min)" | awk -F. '{printf("%d%03d%03d\n",$$1,$$2,$$3);}' 2>/dev/null)
docker_ver := $(shell docker info 2>/dev/null | grep -i "server version" | rev | cut -d' ' -f1 | rev | awk -F. '{printf("%d%03d%03d\n",$$1,$$2,$$3);}' 2>/dev/null)
docker_is_valid := $(shell if [[ "$(docker_ver)" -lt $(docker_min_ver) ]] ; then echo "0"; else echo "1"; fi)
ifeq (0,$(docker_is_valid))
$(error SONiC requires Docker version $(docker_min) or later)
endif

# Remove lock file in case previous run was forcefully stopped
$(shell rm -f .screen)

MAKEFLAGS += -B

CFG_PLATFORM = $(if $(PLATFORM),$(PLATFORM),$(shell cat .platform 2>/dev/null))
ifeq ($(BLDENV), stretch)
SLAVE_BASE_TAG = $(shell cat sonic-slave-stretch/Dockerfile .git/HEAD | sha1sum | awk '{print substr($$1,0,11);}')
SLAVE_TAG = $(shell (cat sonic-slave-stretch/Dockerfile.user sonic-slave-stretch/Dockerfile .git/HEAD && echo $(USER)/$(PWD)/$(CFG_PLATFORM)) | sha1sum | awk '{print substr($$1,0,11);}')
SLAVE_BASE_IMAGE = sonic-slave-stretch-base
SLAVE_IMAGE = sonic-slave-stretch-$(USER)
SLAVE_DIR = sonic-slave-stretch
else
SLAVE_BASE_TAG = $(shell cat sonic-slave/Dockerfile .git/HEAD | sha1sum | awk '{print substr($$1,0,11);}')
SLAVE_TAG = $(shell (cat sonic-slave/Dockerfile.user sonic-slave/Dockerfile .git/HEAD && echo $(USER)/$(PWD)/$(CFG_PLATFORM)) | sha1sum | awk '{print substr($$1,0,11);}')
SLAVE_BASE_IMAGE = sonic-slave-base
SLAVE_IMAGE = sonic-slave-$(USER)
SLAVE_DIR = sonic-slave
endif

OVERLAY_MODULE_CHECK := lsmod | grep "^overlay " > /dev/null 2>&1 || (echo "ERROR: Module 'overlay' not loaded. Try running 'sudo modprobe overlay'."; exit 1)

BUILD_TIMESTAMP := $(shell date +%Y%m%d\.%H%M%S)

# If externally-specified timestamp is provided, use it for consistency throughout build phases.
ifneq ($(EXT_BUILD_TIMESTAMP),)
override BUILD_TIMESTAMP := $(EXT_BUILD_TIMESTAMP)
endif

BASE_IMAGE_LOCK_FILE_NAME := $(LOCK_DIR)/$(SLAVE_BASE_TAG).lock
USER_IMAGE_LOCK_FILE_NAME := $(LOCK_DIR)/$(USER).lock

# Create Docker lockfile for saving and loading an image.
ifeq ($(DOCKER_LOCKDIR),)
override DOCKER_LOCKDIR := /tmp/docklock
endif
DOCKER_LOCKFILE_SAVE := $(DOCKER_LOCKDIR)/docker_save.lock
$(shell mkdir -m 0777 -p $(DOCKER_LOCKDIR))
$(shell [ -f $(DOCKER_LOCKFILE_SAVE) ] || (touch $(DOCKER_LOCKFILE_SAVE) && chmod 0777 $(DOCKER_LOCKFILE_SAVE)))

ifeq ($(DOCKER_BUILDER_MOUNT),)
override DOCKER_BUILDER_MOUNT := "$(PWD):/sonic"
endif

ifeq ($(DOCKER_BUILDER_WORKDIR),)
override DOCKER_BUILDER_WORKDIR := "/sonic"
endif

DOCKER_RUN := docker run --rm=true --privileged \
    -v $(DOCKER_BUILDER_MOUNT) \
    -v "$(DOCKER_LOCKDIR):$(DOCKER_LOCKDIR)" \
    -w $(DOCKER_BUILDER_WORKDIR) \
    -e "http_proxy=$(http_proxy)" \
    -e "https_proxy=$(https_proxy)" \
    -i$(if $(TERM),t,)

include rules/config

# Set up kernel cache path value to pass into docker run command.
# This is also set up in slave.mk, but that's too late for passing into docker.
ifeq ($(KERNEL_CACHE_PATH),)
override KERNEL_CACHE_PATH := $(strip $(DEFAULT_KERNEL_CACHE_PATH))
endif

ifneq ($(KERNEL_CACHE_PATH),)
    DOCKER_RUN += -v "$(KERNEL_CACHE_PATH):/kernel_cache"
endif


ifneq ($(SONIC_DPKG_CACHE_SOURCE),)
    DOCKER_RUN += -v "$(SONIC_DPKG_CACHE_SOURCE):/dpkg_cache"
endif


ifneq  ($(LOCAL_SAI_DEBS_PATH),)
override LOCAL_SAI_DEBS_PATH := $(patsubst %/,%,$(strip $(LOCAL_SAI_DEBS_PATH)))
endif

ifneq ($(LOCAL_SAI_DEBS_PATH),)
    DOCKER_RUN += -v "$(LOCAL_SAI_DEBS_PATH):/sai_libs"
endif

# If SONIC_CONFIG_NATIVE_DOCKERD_SHARED is enabled, force
# SONIC_CONFIG_USE_NATIVE_DOCKERD_FOR_BUILD enabled as well.
ifeq ($(strip $(SONIC_CONFIG_NATIVE_DOCKERD_SHARED)),y)
override SONIC_CONFIG_USE_NATIVE_DOCKERD_FOR_BUILD := y
endif

# User name and tag for "docker-*" images created by native dockerd mode.
ifeq ($(strip $(SONIC_CONFIG_NATIVE_DOCKERD_SHARED)),y)
DOCKER_USERNAME = -$(USER)
DOCKER_USERTAG = $(SLAVE_TAG)
else
DOCKER_USERNAME =
DOCKER_USERTAG = latest
endif

# Define canned sequence to clean up Docker image cache.
#   - These are the remnants from building the runtime Docker images using native (host) Docker daemon.
#   - Image naming convention differs on a shared build system vs. non-shared.
# $(docker-image-cleanup)
ifeq ($(SONIC_CONFIG_USE_NATIVE_DOCKERD_FOR_BUILD),y)
define docker-image-cleanup
    @for i in $(shell docker images --quiet --filter 'dangling=true') ; do (docker rmi $$i &> /dev/null || true) ; done
    @for i in $(shell docker images --quiet docker-*$(DOCKER_USERNAME):$(DOCKER_USERTAG)) ; do (docker rmi $$i &> /dev/null || true) ; done
endef
else
define docker-image-cleanup
    @:
endef
endif

ifeq ($(SONIC_CONFIG_USE_NATIVE_DOCKERD_FOR_BUILD), y)
    DOCKER_RUN += -v /var/run/docker.sock:/var/run/docker.sock
endif

DOCKER_BASE_BUILD = docker build --no-cache \
                    -t $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) \
                    --build-arg http_proxy=$(http_proxy) \
                    --build-arg https_proxy=$(https_proxy) \
                    --build-arg debian_archive_mirror=$(DEBIAN_ARCHIVE_MIRROR) \
                    --build-arg debian_org_mirror=$(DEBIAN_ORG_MIRROR) \
                    $(SLAVE_DIR)

DOCKER_BUILD = docker build --no-cache \
               --build-arg user=$(USER) \
               --build-arg uid=$(shell id -u) \
               --build-arg guid=$(shell id -g) \
               --build-arg hostname=$(shell echo $$HOSTNAME) \
               --build-arg slave_base_tag_ref=$(SLAVE_BASE_TAG) \
               --build-arg debian_archive_mirror=$(DEBIAN_ARCHIVE_MIRROR) \
               --build-arg debian_org_mirror=$(DEBIAN_ORG_MIRROR) \
               -t $(SLAVE_IMAGE):$(SLAVE_TAG) \
               -f $(SLAVE_DIR)/Dockerfile.user \
               $(SLAVE_DIR)


DOCKER_BASE_BUILD_PROTECTED_REGISTRY_PULL = \
                        docker inspect --type image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) &> /dev/null ||   \
                        $(if $(DOCKER_REGISTRY_SERVER), \
                            if [[ $$(curl -s -k -X GET https://$(DOCKER_REGISTRY_SERVER)/v2/$(SLAVE_BASE_IMAGE)/tags/list | grep $(SLAVE_BASE_TAG)) ]]; then \
                                docker pull $(DOCKER_REGISTRY_SERVER)/$(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) && \
                                docker tag $(DOCKER_REGISTRY_SERVER)/$(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) && \
                                docker rmi $(DOCKER_REGISTRY_SERVER)/$(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) ; \
                            fi, echo \
                         )

DOCKER_BASE_BUILD_PROTECTED_REGISTRY_PUSH = \
                        $(if $(DOCKER_REGISTRY_SERVER), \
                            if [[ ! $$(curl -s -k -X GET https://$(DOCKER_REGISTRY_SERVER)/v2/$(SLAVE_BASE_IMAGE)/tags/list | grep $(SLAVE_BASE_TAG)) ]]; then \
                                docker tag $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) $(DOCKER_REGISTRY_SERVER)/$(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) && \
                                docker push $(DOCKER_REGISTRY_SERVER)/$(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) || \
                                echo "Docker registry push failed for $(DOCKER_REGISTRY_SERVER)/$(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG)" && \
                                docker rmi $(DOCKER_REGISTRY_SERVER)/$(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG); \
                            fi ,echo \
                         )



DOCKER_BASE_BUILD_PROTECTED = echo "Start time: "`date`; \
                              echo "Attempting to acquire base image lock (waiting up to $(BASE_IMAGE_LOCK_TIMEOUT_SECS) seconds)..."; \
                              [ -d $(LOCK_DIR) ] || (mkdir -p $(LOCK_DIR) && chmod 0777 $(LOCK_DIR)); \
                              touch $(BASE_IMAGE_LOCK_FILE_NAME) && \
                              exec {BASE_IMAGE_LOCK_FD}<$(BASE_IMAGE_LOCK_FILE_NAME); \
                              if ! flock -x -w $(BASE_IMAGE_LOCK_TIMEOUT_SECS) $${BASE_IMAGE_LOCK_FD}; then \
                                  echo "ERROR: Could not acquire base image lock. Try resubmitting your build."; \
                                  exit 1; \
                              else \
                                  echo "Base image lock acquired. Continuing..."; \
                                  docker inspect --type image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) &> /dev/null || \
                                  $(DOCKER_BASE_BUILD); \
                                  docker_rc=$$?; \
                                  [ $${docker_rc} -eq 0 ] &&  $(DOCKER_BASE_BUILD_PROTECTED_REGISTRY_PUSH); \
                                  eval exec "$${BASE_IMAGE_LOCK_FD}<&-"; \
                                  exit $${docker_rc}; \
                              fi

DOCKER_BUILD_PROTECTED = echo "Start time: "`date`; \
                         echo "Attempting to acquire user image lock (waiting up to $(USER_IMAGE_LOCK_TIMEOUT_SECS) seconds)..."; \
                         [ -d $(LOCK_DIR) ] || (mkdir -p $(LOCK_DIR) && chmod 0777 $(LOCK_DIR)); \
                         touch $(USER_IMAGE_LOCK_FILE_NAME) && \
                         exec {USER_IMAGE_LOCK_FD}<$(USER_IMAGE_LOCK_FILE_NAME) ; \
                         if ! flock -x -w $(USER_IMAGE_LOCK_TIMEOUT_SECS) $${USER_IMAGE_LOCK_FD}; then  \
                             echo "ERROR: Could not acquire user image lock. Try resubmitting your build."; \
                             exit 1; \
                         else \
                             echo "User image lock acquired. Continuing..."; \
                             $(DOCKER_BUILD); \
                             docker_rc=$$?; \
                             eval exec "$${USER_IMAGE_LOCK_FD}<&-"; \
                             exit $${docker_rc}; \
                         fi

SONIC_BUILD_INSTRUCTION :=  make \
                           -f slave.mk \
                           BLDENV=$(BLDENV) \
                           PLATFORM=$(PLATFORM) \
                           BUILD_NUMBER=$(BUILD_NUMBER) \
                           BUILD_PRODUCT=$(BUILD_PRODUCT) \
                           BUILD_TIMESTAMP=$(BUILD_TIMESTAMP) \
                           SLAVE_TAG=$(SLAVE_TAG) \
                           ENABLE_DHCP_GRAPH_SERVICE=$(ENABLE_DHCP_GRAPH_SERVICE) \
                           ENABLE_ZTP=$(ENABLE_ZTP) \
                           ENABLE_PDE=$(ENABLE_PDE) \
                           SHUTDOWN_BGP_ON_START=$(SHUTDOWN_BGP_ON_START) \
                           SONIC_ENABLE_PFCWD_ON_START=$(ENABLE_PFCWD_ON_START) \
                           SONIC_ENABLE_SYNCD_RPC=$(ENABLE_SYNCD_RPC) \
                           SONIC_INSTALL_DEBUG_TOOLS=$(INSTALL_DEBUG_TOOLS) \
                           SONIC_DEBUGGING_ON_PARAM=$(SONIC_DEBUGGING_ON) \
                           SONIC_PROFILING_ON_PARAM=$(SONIC_PROFILING_ON) \
                           SONIC_COVERAGE_ON_PARAM=$(SONIC_COVERAGE_ON) \
                           PASSWORD=$(PASSWORD) \
                           USERNAME=$(USERNAME) \
                           SONIC_BUILD_JOBS=$(SONIC_BUILD_JOBS) \
                           SONIC_MAKE_JOBS=$(SONIC_MAKE_JOBS) \
                           VS_PREPARE_MEM=$(VS_PREPARE_MEM) \
                           KERNEL_PROCURE_METHOD=$(KERNEL_PROCURE_METHOD) \
                           KERNEL_CACHE_PATH=$(KERNEL_CACHE_PATH) \
                           SONIC_DPKG_CACHE_METHOD=$(SONIC_DPKG_CACHE_METHOD) \
                           SONIC_DPKG_CACHE_SOURCE=$(SONIC_DPKG_CACHE_SOURCE) \
                           HTTP_PROXY=$(http_proxy) \
                           HTTPS_PROXY=$(https_proxy) \
                           DOCKER_USERNAME=$(DOCKER_USERNAME) \
                           DOCKER_USERTAG=$(DOCKER_USERTAG) \
                           DOCKER_LOCKFILE_SAVE=$(DOCKER_LOCKFILE_SAVE) \
                           SONIC_CONFIG_USE_NATIVE_DOCKERD_FOR_BUILD=$(SONIC_CONFIG_USE_NATIVE_DOCKERD_FOR_BUILD) \
                           SONIC_CONFIG_NATIVE_DOCKERD_SHARED=$(SONIC_CONFIG_NATIVE_DOCKERD_SHARED) \
                           SONIC_ENABLE_SYSTEM_TELEMETRY=$(ENABLE_SYSTEM_TELEMETRY) \
                           LOCAL_SAI_DEBS_PATH=$(LOCAL_SAI_DEBS_PATH) \
                           EXTRA_JESSIE_TARGETS=$(EXTRA_JESSIE_TARGETS) \
                           $(SONIC_OVERRIDE_BUILD_VARS)

PDESUBMODULES = src/sonic-linux-kernel \
                src/sonic-utilities \
                src/sonic-platform-common \
                src/sonic-swss-common \
                src/sonic-py-swsssdk \
                src/redis-dump-load \
                src/sonic-sairedis \
                src/sonic-platform-pde

.PHONY: sonic-slave-build sonic-slave-bash init initpde reset developer

.DEFAULT_GOAL :=  all

%::
	@$(OVERLAY_MODULE_CHECK)
	@$(DOCKER_BASE_BUILD_PROTECTED_REGISTRY_PULL)
	@docker inspect --type image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) &> /dev/null || \
	    { echo Image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) not found. Building... ; \
	    $(DOCKER_BASE_BUILD_PROTECTED) ; } || exit 1
	@docker inspect --type image $(SLAVE_IMAGE):$(SLAVE_TAG) &> /dev/null || \
	    { echo Image $(SLAVE_IMAGE):$(SLAVE_TAG) not found. Building... ; \
	    $(DOCKER_BUILD_PROTECTED) ; } || exit 1
ifeq "$(KEEP_SLAVE_ON)" "yes"
    ifdef SOURCE_FOLDER
		@$(DOCKER_RUN) -v $(SOURCE_FOLDER):/var/$(USER)/src $(SLAVE_IMAGE):$(SLAVE_TAG) bash -c "$(SONIC_BUILD_INSTRUCTION) $@; /bin/bash"
    else
		@$(DOCKER_RUN) $(SLAVE_IMAGE):$(SLAVE_TAG) bash -c "$(SONIC_BUILD_INSTRUCTION) $@; /bin/bash"
    endif
else
	@$(DOCKER_RUN) $(SLAVE_IMAGE):$(SLAVE_TAG) $(SONIC_BUILD_INSTRUCTION) $@
endif

docker-cleanup:
	$(docker-image-cleanup)

sonic-slave-build :
	@$(DOCKER_BASE_BUILD_PROTECTED_REGISTRY_PULL)
	@$(DOCKER_BASE_BUILD_PROTECTED) || exit 1
	@$(DOCKER_BUILD_PROTECTED) || exit 1

sonic-slave-bash :
	@$(OVERLAY_MODULE_CHECK)
	@$(DOCKER_BASE_BUILD_PROTECTED_REGISTRY_PULL)
	@docker inspect --type image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) &> /dev/null || \
	    { echo Image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) not found. Building... ; \
	    $(DOCKER_BASE_BUILD_PROTECTED) ; } || exit 1
	@docker inspect --type image $(SLAVE_IMAGE):$(SLAVE_TAG) &> /dev/null || \
	    { echo Image $(SLAVE_IMAGE):$(SLAVE_TAG) not found. Building... ; \
	    $(DOCKER_BUILD_PROTECTED) ; } || exit 1
	@$(DOCKER_RUN) -t $(SLAVE_IMAGE):$(SLAVE_TAG) bash

showtag:
	@echo $(SLAVE_IMAGE):$(SLAVE_TAG)
	@echo $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG)

developer :
	@sed -i 's|# INSTALL_DEBUG_TOOLS = y|INSTALL_DEBUG_TOOLS = y|' rules/config
	@sed -i 's|#SONIC_DEBUGGING_ON = y|SONIC_DEBUGGING_ON = y|' rules/config
	@sed -i 's|DEFAULT_KERNEL_PROCURE_METHOD = build|DEFAULT_KERNEL_PROCURE_METHOD = cache|' rules/config

initpde:
	@for submodule in $(PDESUBMODULES) ; do \
	git submodule update --init --recursive $$submodule ; \
	done
	@git submodule foreach --recursive '[ -f .git ] && echo "gitdir: $$(realpath --relative-to=. $$(cut -d" " -f2 .git))" > .git'

init :
	@git submodule update --init --recursive
	@git submodule foreach --recursive '[ -f .git ] && echo "gitdir: $$(realpath --relative-to=. $$(cut -d" " -f2 .git))" > .git'

reset :
	@echo && echo -n "Warning! All local changes will be lost. Proceed? [y/N]: "
	@read ans && \
	    if [ $$ans == y ]; then \
	        echo "Resetting local repository. Please wait..."; \
	        $(DOCKER_RUN) $(SLAVE_IMAGE):$(SLAVE_TAG) sudo rm -rf fsroot; \
	        git clean -xfdf; \
	        git reset --hard; \
	        git submodule foreach --recursive git clean -xfdf; \
	        git submodule foreach --recursive git reset --hard; \
	        git submodule update --init --recursive; \
			echo "Reset complete!"; \
	    else \
	        echo "Reset aborted"; \
	    fi
