#!/usr/bin/python -u
# -*- coding: utf-8 -*-

mmmmzzzzz

import os
import re
import sys
import subprocess
import syslog
import copy
import jinja2
import ipaddress
import netaddr
from swsssdk import ConfigDBConnector

# FILE
PAM_AUTH_CONF = "/etc/pam.d/common-auth-sonic"
PAM_AUTH_CONF_TEMPLATE = "/usr/share/sonic/templates/common-auth-sonic.j2"
NSS_TACPLUS_CONF = "/etc/tacplus_nss.conf"
NSS_TACPLUS_CONF_TEMPLATE = "/usr/share/sonic/templates/tacplus_nss.conf.j2"
NSS_RADIUS_CONF = "/etc/radius_nss.conf"
NSS_RADIUS_CONF_TEMPLATE = "/usr/share/sonic/templates/radius_nss.conf.j2"
PAM_RADIUS_AUTH_CONF_TEMPLATE = "/usr/share/sonic/templates/pam_radius_auth.conf.j2"
NSS_CONF = "/etc/nsswitch.conf"

# TACACS+
TACPLUS_SERVER_PASSKEY_DEFAULT = ""
TACPLUS_SERVER_TIMEOUT_DEFAULT = "5"
TACPLUS_SERVER_AUTH_TYPE_DEFAULT = "pap"

# RADIUS
RADIUS_SERVER_AUTH_PORT_DEFAULT = "1812"
RADIUS_SERVER_PASSKEY_DEFAULT = ""
RADIUS_SERVER_RETRANSMIT_DEFAULT = "3"
RADIUS_SERVER_TIMEOUT_DEFAULT = "5"
RADIUS_SERVER_AUTH_TYPE_DEFAULT = "pap"
RADIUS_PAM_AUTH_CONF_DIR = "/etc/pam_radius_auth.d/"


def is_valid_hostname(hostname):
    if hostname[-1] == "." or len(hostname) > 253:
        return False
    allowed = re.compile("(?!-)[A-Z\d-]{1,63}(?<!-)$", re.IGNORECASE)
    return all(allowed.match(x) for x in hostname.split("."))


def is_true(val):
    if val == 'True' or val == 'true':
        return True
    else:
        return False


def sub(l, start, end):
    return l[start:end]


def obfuscate(data):
    if data:
        return data[0] + '*****'
    else:
        return data

class Iptables(object):
    def __init__(self):
        '''
        Default MSS to 1460 - (MTU 1500 - 40 (TCP/IP Overhead))
        For IPv6, it would be 1440 - (MTU 1500 - 60 octects)
        '''
        self.tcpmss = 1460
        self.tcp6mss = 1440

    def is_ip_prefix_in_key(self, key):
        '''
        Function to check if IP address is present in the key. If it
        is present, then the key would be a tuple or else, it shall be
        be string
        '''
        return (isinstance(key, tuple))

    def load(self, lpbk_table):
        for row in lpbk_table:
            self.iptables_handler(row, lpbk_table[row])

    def command(self, chain, ip, ver, op):
        cmd = 'iptables' if ver == '4' else 'ip6tables'
        cmd += ' -t mangle --{} {} -p tcp --tcp-flags SYN SYN'.format(op, chain)
        cmd += ' -d' if chain == 'PREROUTING' else ' -s'
        mss = self.tcpmss if ver == '4' else self.tcp6mss
        cmd += ' {} -j TCPMSS --set-mss {}'.format(ip, mss)

        return cmd

    def iptables_handler(self, key, data, add=True):
        if not self.is_ip_prefix_in_key(key):
            return

        iface, ip = key
        ip_str = ip.split("/")[0]
        ip_addr = ipaddress.IPAddress(ip_str)
        if isinstance(ip_addr, ipaddress.IPv6Address):
            ver = '6'
        else:
            ver = '4'

        self.mangle_handler(ip_str, ver, add)

    def mangle_handler(self, ip, ver, add):
        if not add:
            op = 'delete'
        else:
            op = 'check'

        iptables_cmds = []
        chains = ['PREROUTING', 'POSTROUTING']
        for chain in chains:
            cmd = self.command(chain, ip, ver, op)
            if not add:
                iptables_cmds.append(cmd)
            else:
                '''
                For add case, first check if rule exists. Iptables just appends to the chain
                as a new rule even if it is the same as an existing one. Check this and
                do nothing if rule exists
                '''
                ret = subprocess.call(cmd, shell=True)
                if ret == 0:
                    syslog.syslog(syslog.LOG_INFO, "{} rule exists in {}".format(ip, chain))
                else:
                    # Modify command from Check to Append
                    iptables_cmds.append(cmd.replace("check", "append"))

        for cmd in iptables_cmds:
            syslog.syslog(syslog.LOG_INFO, "Running cmd - {}".format(cmd))
            try:
                subprocess.check_call(cmd, shell=True)
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                              .format(err.cmd, err.returncode, err.output))

class AaaCfg(object):
    def __init__(self):
        self.auth_default = {
            'login': 'local',
        }
        self.tacplus_global_default = {
            'priority': 0,
            'auth_type': TACPLUS_SERVER_AUTH_TYPE_DEFAULT,
            'timeout': TACPLUS_SERVER_TIMEOUT_DEFAULT,
            'passkey': TACPLUS_SERVER_PASSKEY_DEFAULT
        }
        self.tacplus_global = {}
        self.tacplus_servers = {}
        self.radius_global_default = {
            'priority': 0,
            'auth_port': RADIUS_SERVER_AUTH_PORT_DEFAULT,
            'auth_type': RADIUS_SERVER_AUTH_TYPE_DEFAULT,
            'retransmit': RADIUS_SERVER_RETRANSMIT_DEFAULT,
            'timeout': RADIUS_SERVER_TIMEOUT_DEFAULT,
            'passkey': RADIUS_SERVER_PASSKEY_DEFAULT
        }
        self.radius_global = {}
        self.radius_servers = {}
        self.auth = {}
        self.debug = False

    # Load conf from ConfigDb
    def load(self, aaa_conf, tac_global_conf, tacplus_conf, rad_global_conf, radius_conf):
        for row in aaa_conf:
            self.aaa_update(row, aaa_conf[row], modify_conf=False)
        for row in tac_global_conf:
            self.tacacs_global_update(row, tac_global_conf[row], modify_conf=False)
        for row in tacplus_conf:
            self.tacacs_server_update(row, tacplus_conf[row], modify_conf=False)
        for row in rad_global_conf:
            self.radius_global_update(row, rad_global_conf[row], modify_conf=False)
        for row in radius_conf:
            self.radius_server_update(row, radius_conf[row], modify_conf=False)
        self.modify_conf_file()

    def aaa_update(self, key, data, modify_conf=True):
        if key == 'authentication':
            self.auth = data
            if 'failthrough' in data:
                self.auth['failthrough'] = is_true(data['failthrough'])
            if 'debug' in data:
                self.debug = is_true(data['debug'])
        if modify_conf:
            self.modify_conf_file()

    def tacacs_global_update(self, key, data, modify_conf=True):
        if key == 'global':
            self.tacplus_global = data
            if modify_conf:
                self.modify_conf_file()

    def tacacs_server_update(self, key, data, modify_conf=True):
        if data == {}:
            if key in self.tacplus_servers:
                del self.tacplus_servers[key]
        else:
            self.tacplus_servers[key] = data

        if modify_conf:
            self.modify_conf_file()

    def radius_global_update(self, key, data, modify_conf=True):
        if key == 'global':
            self.radius_global = data
            if modify_conf:
                self.modify_conf_file()

    def radius_server_update(self, key, data, modify_conf=True):
        if data == {}:
            if key in self.radius_servers:
                del self.radius_servers[key]
        else:
            self.radius_servers[key] = data

        if modify_conf:
            self.modify_conf_file()

    def modify_conf_file(self):
        auth = self.auth_default.copy()
        auth.update(self.auth)
        tacplus_global = self.tacplus_global_default.copy()
        tacplus_global.update(self.tacplus_global)

        servers_conf = []
        if self.tacplus_servers:
            for addr in self.tacplus_servers:
                server = tacplus_global.copy()
                server['ip'] = addr
                server.update(self.tacplus_servers[addr])
                servers_conf.append(server)
            servers_conf = sorted(servers_conf, key=lambda t: int(t['priority']), reverse=True)

        radius_global = self.radius_global_default.copy()
        radius_global.update(self.radius_global)

        radsrvs_conf = []
        if self.radius_servers:
            for addr in self.radius_servers:
                server = radius_global.copy()
                server['ip'] = addr
                server.update(self.radius_servers[addr])
                radsrvs_conf.append(server)
            radsrvs_conf = sorted(radsrvs_conf, key=lambda t: int(t['priority']), reverse=True)

        template_file = os.path.abspath(PAM_AUTH_CONF_TEMPLATE)
        env = jinja2.Environment(loader=jinja2.FileSystemLoader('/'), trim_blocks=True)
        env.filters['sub'] = sub
        template = env.get_template(template_file)
        if 'radius' in auth['login']:
            pam_conf = template.render(debug=self.debug, auth=auth, servers=radsrvs_conf)
        else:
            pam_conf = template.render(debug=self.debug, auth=auth, servers=servers_conf)
        
        with open(PAM_AUTH_CONF, 'w') as f:
            f.write(pam_conf)

        # Modify common-auth include file in /etc/pam.d/login and sshd
        if os.path.isfile(PAM_AUTH_CONF):
            os.system("sed -i -e '/^@include/s/common-auth$/common-auth-sonic/' /etc/pam.d/sshd")
            os.system("sed -i -e '/^@include/s/common-auth$/common-auth-sonic/' /etc/pam.d/login")
        else:
            os.system("sed -i -e '/^@include/s/common-auth-sonic$/common-auth/' /etc/pam.d/sshd")
            os.system("sed -i -e '/^@include/s/common-auth-sonic$/common-auth/' /etc/pam.d/login")

        # Add tacplus/radius in nsswitch.conf if TACACS+/RADIUS enable
        if 'tacacs+' in auth['login']:
            if os.path.isfile(NSS_CONF):
                os.system("sed -i -e '/^passwd/s/ radius//' -e '/tacplus/b' -e '/^passwd/s/compat/tacplus &/' /etc/nsswitch.conf")
        elif 'radius' in auth['login']:
            if os.path.isfile(NSS_CONF):
                os.system("sed -i -e '/^passwd/s/tacplus //' -e '/radius/b' -e '/^passwd/s/compat/& radius/' /etc/nsswitch.conf")
        else:
            if os.path.isfile(NSS_CONF):
                os.system("sed -i -e '/^passwd/s/tacplus //' -e '/^passwd/s/ radius//' /etc/nsswitch.conf")

        # Set tacacs+ server in nss-tacplus conf
        template_file = os.path.abspath(NSS_TACPLUS_CONF_TEMPLATE)
        template = env.get_template(template_file)
        nss_tacplus_conf = template.render(debug=self.debug, servers=servers_conf)
        with open(NSS_TACPLUS_CONF, 'w') as f:
            f.write(nss_tacplus_conf)

        # Set debug in nss-radius conf
        template_file = os.path.abspath(NSS_RADIUS_CONF_TEMPLATE)
        template = env.get_template(template_file)
        nss_radius_conf = template.render(debug=self.debug, servers=radsrvs_conf)
        with open(NSS_RADIUS_CONF, 'w') as f:
            f.write(nss_radius_conf)

        # Create the per server pam_radius_auth.conf
        if self.radius_servers:
            for addr in self.radius_servers:
                srv = radius_global.copy()
                srv['ip'] = addr
                srv.update(self.radius_servers[addr])
                pam_radius_auth_file = RADIUS_PAM_AUTH_CONF_DIR + addr + ":" + srv['auth_port'] + ".conf"
                template_file = os.path.abspath(PAM_RADIUS_AUTH_CONF_TEMPLATE)
                template = env.get_template(template_file)
                pam_radius_auth_conf = template.render(server=srv)

                with open(pam_radius_auth_file, 'w') as f:
                    f.write(pam_radius_auth_conf)


CFG_MGMT_INTF_TABLE = "MGMT_INTERFACE"
CFG_MGMT_VRF      = "MGMT_VRF_CONFIG"
CFG_MGMT_VRF_KEY  = "vrf_global"
MGMT_VRF_TABLE_ID = 5000

class MgmtVrfCfg:
    def __init__(self, config_db):
        syslog.syslog(syslog.LOG_INFO, 'Initializing MGMT VRF handler')
        self.config_db = config_db
        self.mgmt_vrf_table_created = False

    def create_mgmt_vrf_table(self):
        if self.mgmt_vrf_table_created == False:
            syslog.syslog(syslog.LOG_INFO, "Create MGMT VRF table:")
            cmd = 'ip link add name mgmt type vrf table {}'.format(MGMT_VRF_TABLE_ID)
            syslog.syslog(syslog.LOG_INFO, "Create MGMT VRF table, cmd - {}".format(cmd))
            try:
                subprocess.check_call(cmd, shell=True)
                self.mgmt_vrf_table_created = True
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                        .format(err.cmd, err.returncode, err.output))

    def delete_mgmt_vrf_table(self):
        if self.mgmt_vrf_table_created == True:
            syslog.syslog(syslog.LOG_INFO, "Delete MGMT VRF table:")
            cmd = 'ip link delete mgmt'
            syslog.syslog(syslog.LOG_INFO, "Delete MGMT VRF table, cmd - {}".format(cmd))
            try:
                subprocess.check_call(cmd, shell=True)
                self.mgmt_vrf_table_created = False
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                        .format(err.cmd, err.returncode, err.output))

            cmd = 'cgdelete -g l3mdev:mgmt'
            syslog.syslog(syslog.LOG_INFO, "Delete mgmt l3mdev group, cmd - {}".format(cmd))
            try:
                subprocess.check_call(cmd, shell=True)
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                        .format(err.cmd, err.returncode, err.output))

    def configure_mgmt_vrf(self):
        syslog.syslog(syslog.LOG_INFO,  "Configure MGMT VRF:")
        self.create_mgmt_vrf_table()
        
        cmd = 'ip link set dev mgmt up'
        syslog.syslog(syslog.LOG_INFO, "Set MGMT VRF up, cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))
            return

        syslog.syslog(syslog.LOG_INFO, "Add lo intf:")

        cmd = 'ip link add lo-m type dummy'
        syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))
            return

        cmd = 'ip addr add 127.0.0.1/8 dev lo-m'
        syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))
            return

        cmd = 'ip link set lo-m up'
        syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))
            return

        cmd = 'ip link set dev lo-m master mgmt'
        syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))
            return

        self.bind_mgmt_intf()

    def bind_mgmt_intf(self):
        syslog.syslog(syslog.LOG_INFO, "Handle MGMT intf:")
        keys = self.config_db.get_keys(CFG_MGMT_INTF_TABLE)
        syslog.syslog(syslog.LOG_INFO, "MGMT interfaces keys: {}".format(str(keys)))

        mgmt_intf_bound = False
        for it in keys:
            if type(it) is unicode:

                mgmt_intf_name = it

                cmd = 'ip link set dev {} master mgmt'.format(mgmt_intf_name)
                syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
                try:
                    subprocess.check_call(cmd, shell=True)
                except subprocess.CalledProcessError as err:
                    syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                            .format(err.cmd, err.returncode, err.output))
                    return

                cmd = 'sysctl -w net.ipv4.tcp_l3mdev_accept=1'
                syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
                try:
                    subprocess.check_call(cmd, shell=True)
                except subprocess.CalledProcessError as err:
                    syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                            .format(err.cmd, err.returncode, err.output))
                    return

                mgmt_intf_bound = True
                break

        if not mgmt_intf_bound:
            syslog.syslog(syslog.LOG_ERR, "MGMT VRF: MGMT interface not bound")
        else:
            for it in keys:
                if type(it) is unicode:
                    key = it
                else:
                    key = it[0] + "|" + it[1]

                entry = self.config_db.get_entry(CFG_MGMT_INTF_TABLE, key)
                if 'gwaddr' in entry:
                    mgmt_intf_gwaddr = entry['gwaddr']
                    cmd = 'ip route add table {} 0.0.0.0/0 via {}'.format(MGMT_VRF_TABLE_ID, mgmt_intf_gwaddr)
                    syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
                    try:
                        subprocess.check_call(cmd, shell=True)
                    except subprocess.CalledProcessError as err:
                        syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                                .format(err.cmd, err.returncode, err.output))
                        return

            cmd = 'cgcreate -g l3mdev:mgmt'
            syslog.syslog(syslog.LOG_INFO, "Create mgmt l3mdev group - {}".format(cmd))
            try:
                subprocess.check_call(cmd, shell=True)
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                        .format(err.cmd, err.returncode, err.output))

            cmd = 'cgset -r l3mdev.master-device=mgmt mgmt'
            syslog.syslog(syslog.LOG_INFO, "Set cmd - {}".format(cmd))
            try:
                subprocess.check_call(cmd, shell=True)
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                        .format(err.cmd, err.returncode, err.output))


    def unconfigure_mgmt_vrf(self):
        syslog.syslog(syslog.LOG_INFO, "Unconfigure MGMT VRF:")

        cmd = 'ip link delete lo-m'
        syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))

        self.delete_mgmt_vrf_table()
        return

    def handle_mgmt_intf_gwaddr_cfg(self, op, ifname, gwaddr):
        syslog.syslog(syslog.LOG_INFO, "Received MGMT Intf gwaddr config, op: {}, ifname: {}, gwaddr: {}".format(op, ifname, gwaddr))
        keys = self.config_db.get_keys(CFG_MGMT_VRF)
        if keys:
            syslog.syslog(syslog.LOG_INFO, "MGMT VRF created")

            cmd = 'ip route del table {} 0.0.0.0/0'.format(MGMT_VRF_TABLE_ID)
            syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
            try:
                subprocess.check_call(cmd, shell=True)
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}".format(err.cmd, err.returncode, err.output))
                pass

            if op == "ADD":
                cmd = 'ip route add table {} 0.0.0.0/0 via {}'.format(MGMT_VRF_TABLE_ID, gwaddr)
                syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
                try:
                    subprocess.check_call(cmd, shell=True)
                except subprocess.CalledProcessError as err:
                    syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}".format(err.cmd, err.returncode, err.output))
                    pass

            return True

    def handle_mgmt_intf_creation(self, mgmt_intf_key):
        syslog.syslog(syslog.LOG_INFO, "Received MGMT Intf creation, key: {}".format(mgmt_intf_key))
        keys = self.config_db.get_keys(CFG_MGMT_VRF)
        if keys:
            syslog.syslog(syslog.LOG_INFO, "MGMT VRF created")
            self.bind_mgmt_intf()

    def handle_mgmt_vrf_cfg(self, key, data):
        syslog.syslog(syslog.LOG_INFO, "Received MGMT VRF config, key: {}, data: {}".format(key, data))
        try:
            if data:
                if data['mgmtVrfEnabled'] == 'true':
                    self.configure_mgmt_vrf()
                else:
                    self.unconfigure_mgmt_vrf()
            else:
                self.unconfigure_mgmt_vrf()

        except:
            syslog.syslog(syslog.LOG_ERR, "{} MGMT VRF Configuration failed.".format(key))

MGMT_INTF_ADMIN_STATUS_DEFAULT = "up"
CFG_MGMT_PORT_TABLE = "MGMT_PORT"
APP_MGMT_PORT_TABLE = "MGMT_PORT_TABLE"
APP_MGMT_INTF_TABLE = "MGMT_INTF_TABLE"


class MgmtIntfCfg:
    def __init__(self, mgmt_vrf_cfg):
        self.app_db = ConfigDBConnector()
        self.app_db.db_connect('APPL_DB', wait_for_init=False, retry_on=True)
        self.mgmt_vrf_cfg = mgmt_vrf_cfg
        syslog.syslog(syslog.LOG_INFO, 'AppDB connect success')

    def mgmt_intf_handle_default_cfg (self, config_db):
        key = "eth0"
        mgmt_intf = config_db.get_entry(CFG_MGMT_PORT_TABLE, key)
        if mgmt_intf == {}:
            mgmt_intf['mtu'] = "1500"
            mgmt_intf['speed'] = "1000"
            mgmt_intf['admin_status'] = MGMT_INTF_ADMIN_STATUS_DEFAULT
            mgmt_intf['autoneg'] = "true"
            mgmt_intf['description'] = "Management0"
            syslog.syslog(syslog.LOG_INFO, "Default config populated for {}".format(key))
            config_db.set_entry(CFG_MGMT_PORT_TABLE, key, mgmt_intf)

        self.handle_mgmt_port_cfg(key, mgmt_intf)

    def mgmt_intf_mtu_set (self, ifname, mtu, appIntf):
        cmd = 'ifconfig {} mtu {}'.format(ifname, mtu)
        syslog.syslog(syslog.LOG_INFO, "Configure MTU, cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
            appIntf['mtu'] = mtu
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))

    def mgmt_intf_admin_status_set (self, ifname, admin_status, appIntf):
        cmd = 'ifconfig {} {}'.format(ifname, admin_status)
        syslog.syslog(syslog.LOG_INFO, "Configure admin_status, cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
            appIntf['admin_status'] = admin_status
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))

    def mgmt_intf_description_set (self, ifname, description, appIntf):
        syslog.syslog(syslog.LOG_INFO, "Configure description, cmd - {}".format(description))
        appIntf['description'] = description

    def mgmt_intf_speed_set (self, ifname, speed, autoneg, appIntf):
        duplex = "full"
        cmd = 'ethtool -s {} speed {} duplex {} autoneg {}; ifup {}'.format(ifname, speed, duplex, autoneg, ifname)
        syslog.syslog(syslog.LOG_INFO, "Configure SPEED, cmd - {}".format(cmd))

        try:
            subprocess.check_call(cmd, shell=True)
            appIntf['speed'] = speed
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))

    def mgmt_intf_autoneg_set (self, ifname, autoneg, appIntf):
        an = "on"
        if autoneg == "true":
            an = "on"
        elif autoneg == "false":
            an = "off"
        cmd = "ethtool -s {} autoneg {}".format(ifname, an)
        syslog.syslog(syslog.LOG_INFO, "Configure autoneg, cmd - {}".format(cmd))

        try:
            subprocess.check_call(cmd, shell=True)
            appIntf['autoneg'] = autoneg
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}".format(err.cmd, err.returncode, err.output))

    def mgmt_intf_gwaddr_set(self, ifname, gwaddr, appIntf, op):

        if not self.mgmt_vrf_cfg.handle_mgmt_intf_gwaddr_cfg(op, ifname, gwaddr):
            try:
                if op == "DEL":
                    cmd = "route del default gw {} {}".format(gwaddr, ifname)
                else:
                    cmd = "ip route add default via {} dev {} table default".format(gwaddr, ifname)
                syslog.syslog(syslog.LOG_INFO, "Configure gwaddr , cmd : {}".format(cmd))
                subprocess.check_call(cmd, shell=True)
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}".format(err.cmd, err.returncode, err.output))
                pass




    def mgmt_intf_ip_prefix_set (self, ifname, ip_prefix, op):

        try:
            if op == "DEL":
                ip_prefix = "0.0.0.0"
                mgmt_conf = netaddr.IPNetwork(ip_prefix)
                cmd = "ifconfig {} {}".format(ifname, ip_prefix)
            else:
                mgmt_conf = netaddr.IPNetwork(ip_prefix)
                cmd = "ifconfig {} {} netmask {}".format(ifname, str(mgmt_conf.ip), str(mgmt_conf.netmask))
            syslog.syslog(syslog.LOG_INFO, "Configure ip_prefix, cmd : {}".format(cmd))
            subprocess.check_call(cmd, shell=True)
            cmd = "ip rule add from {} table default".format(str(mgmt_conf.ip))
            subprocess.check_call(cmd, shell=True)
            cmd = "[ -f /var/run/dhclient.{}.pid ] && kill `cat /var/run/dhclient.{}.pid` && rm -f /var/run/dhclient.{}.pid".format(ifname,ifname,ifname)
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}".format(err.cmd, err.returncode, err.output))
            pass


    def handle_mgmt_port_cfg(self, key, data):
        mgmt_intf =  self.app_db.get_entry(APP_MGMT_PORT_TABLE, key)
        is_all = False
        if mgmt_intf == {}:
            is_all = True

        try:
            if (('mtu' in data) and ((is_all == True) or (mgmt_intf == {}) or ('mtu' not in mgmt_intf) or (data['mtu'] != mgmt_intf['mtu']))):
                self.mgmt_intf_mtu_set(key, data['mtu'], mgmt_intf)

            if (('description' in data) and ((is_all == True) or (mgmt_intf == {}) or ('description' not in mgmt_intf) or (data['description'] != mgmt_intf['description']))):
                self.mgmt_intf_description_set(key, data['description'], mgmt_intf)

            if (('admin_status' in data) and ((is_all == True) or (mgmt_intf == {}) or ('admin_status' not in mgmt_intf) or (data['admin_status'] != mgmt_intf['admin_status']))):
                self.mgmt_intf_admin_status_set(key, data['admin_status'], mgmt_intf)

            if (('autoneg' in data) and ((is_all == True) or (mgmt_intf == {}) or ('autoneg' not in mgmt_intf) or (data['autoneg'] != mgmt_intf['autoneg']))):
                self.mgmt_intf_autoneg_set(key, data['autoneg'], mgmt_intf)

            if (('speed' in data) and ((is_all == True) or (mgmt_intf == {}) or ('speed' not in mgmt_intf) or (data['speed'] != mgmt_intf['speed']))):
                autoneg = "on"
                if 'autoneg' in data:
                    if data['autoneg'] == "false":
                        autoneg = "off"
                self.mgmt_intf_speed_set(key, data['speed'], autoneg, mgmt_intf)

        except:
            syslog.syslog(syslog.LOG_ERR, "{} MGMT Port Config set failed.".format(key))

        self.app_db.set_entry(APP_MGMT_PORT_TABLE, key, mgmt_intf)

    def handle_mgmt_intf_cfg(self, key, data, op):
        if op == "CREATE":
            self.mgmt_vrf_cfg.handle_mgmt_intf_creation(key)
            return
        
        intf_keys = key.split("|")
        if (len(intf_keys) < 2):
            return
        input_ip = ipaddress.ip_interface(intf_keys[1])
        cur_appdb_key = key.replace('|', ':')
        appdb_keys = self.app_db.get_table(APP_MGMT_INTF_TABLE).keys()

        for appdb_key in appdb_keys:
            key_slice = appdb_key.split(":")
            current_ip = ipaddress.ip_interface(key_slice[1])
            if (input_ip.version == current_ip.version):
                self.app_db.set_entry(APP_MGMT_INTF_TABLE, "{}".format(appdb_key), None)
        
        mgmt_intf = {}
        self.mgmt_intf_ip_prefix_set(intf_keys[0], intf_keys[1], op)
        if ('gwaddr' in data):
            self.mgmt_intf_gwaddr_set(intf_keys[0], data['gwaddr'], mgmt_intf, op)
            mgmt_intf['gwaddr'] = data['gwaddr']

        if op == "ADD":
            if mgmt_intf == {}:
                mgmt_intf["NULL"] = "NULL"
            self.app_db.set_entry(APP_MGMT_INTF_TABLE, cur_appdb_key, mgmt_intf)


class HostConfigDaemon:
    def __init__(self):
        self.config_db = ConfigDBConnector()
        self.config_db.connect(wait_for_init=True, retry_on=True)
        syslog.syslog(syslog.LOG_INFO, 'ConfigDB connect success')
        aaa = self.config_db.get_table('AAA')
        tacacs_global = self.config_db.get_table('TACPLUS')
        tacacs_server = self.config_db.get_table('TACPLUS_SERVER')
        radius_global = self.config_db.get_table('RADIUS')
        radius_server = self.config_db.get_table('RADIUS_SERVER')
        self.aaacfg = AaaCfg()
        self.aaacfg.load(aaa, tacacs_global, tacacs_server, radius_global, radius_server)
        ssh_server_vrf = self.config_db.get_table('SSH_SERVER_VRF')
        self.load_ssh_server_vrf(ssh_server_vrf)
        self.hostname_cache=""
        self.mgmtvrfcfg = MgmtVrfCfg(self.config_db)
        self.mgmtcfg = MgmtIntfCfg(self.mgmtvrfcfg)
        self.mgmtcfg.mgmt_intf_handle_default_cfg(self.config_db)
        lpbk_table = self.config_db.get_table('LOOPBACK_INTERFACE')
        self.iptables = Iptables()
        self.iptables.load(lpbk_table)

    def aaa_handler(self, key, data):
        self.aaacfg.aaa_update(key, data)

    def load_ssh_server_vrf(self, ssh_server_conf):
        cmd = 'iptables -I INPUT -i Vrf+ -p tcp --dport 22 -j REJECT'
        cmd1 = 'ip6tables -I INPUT -i Vrf+ -p tcp --dport 22 -j REJECT'
        cmd = cmd + ";" + cmd1
        os.system(cmd)
        cmd = 'iptables -I INPUT -i mgmt+ -p tcp --dport 22 -j REJECT'
        cmd1 = 'ip6tables -I INPUT -i mgmt+ -p tcp --dport 22 -j REJECT'
        cmd = cmd + ";" + cmd1
        os.system(cmd)
        for row in ssh_server_conf:
            self.ssh_server_handler(row, ssh_server_conf[row])

    def tacacs_server_handler(self, key, data):
        self.aaacfg.tacacs_server_update(key, data)
        log_data = copy.deepcopy(data)
        if log_data.has_key('passkey'):
            log_data['passkey'] = obfuscate(log_data['passkey'])
        syslog.syslog(syslog.LOG_INFO, 'value of {} changed to {}'.format(key, log_data))

    def tacacs_global_handler(self, key, data):
        self.aaacfg.tacacs_global_update(key, data)
        log_data = copy.deepcopy(data)
        if log_data.has_key('passkey'):
            log_data['passkey'] = obfuscate(log_data['passkey'])
        syslog.syslog(syslog.LOG_INFO, 'value of {} changed to {}'.format(key, log_data))

    def radius_server_handler(self, key, data):
        self.aaacfg.radius_server_update(key, data)
        log_data = copy.deepcopy(data)
        if log_data.has_key('passkey'):
            log_data['passkey'] = obfuscate(log_data['passkey'])
        syslog.syslog(syslog.LOG_INFO, 'value of {} changed to {}'.format(key, log_data))

    def radius_global_handler(self, key, data):
        self.aaacfg.radius_global_update(key, data)
        log_data = copy.deepcopy(data)
        if log_data.has_key('passkey'):
            log_data['passkey'] = obfuscate(log_data['passkey'])
        syslog.syslog(syslog.LOG_INFO, 'value of {} changed to {}'.format(key, log_data))

    def ssh_server_handler(self, key, data):
        
        if data == {}:
            cmd = 'iptables -D INPUT -i {} -p tcp --dport 22 -j ACCEPT'.format(key)
            cmd1 = 'ip6tables -D INPUT -i {} -p tcp --dport 22 -j ACCEPT'.format(key)
        else:
            cmd = 'iptables -I INPUT -i {} -p tcp --dport 22 -j ACCEPT'.format(key)
            cmd1 = 'ip6tables -I INPUT -i {} -p tcp --dport 22 -j ACCEPT'.format(key)
        cmd = cmd + ";" + cmd1
        os.system(cmd)
        syslog.syslog(syslog.LOG_INFO, 'ssh_server_handler cmd:{}'.format(cmd))
        syslog.syslog(syslog.LOG_INFO, 'ssh_server_handler value of {} changed to {}'.format(key, data))

    def hostname_handler(self, key, data):
        if key != "localhost":
            return

        hostname = data.get("hostname")

        if not hostname:
            syslog.syslog(syslog.LOG_WARNING, "hostname key is missing")
            return
        if not is_valid_hostname(hostname):
            syslog.syslog(syslog.LOG_WARNING, "hostname {} is invalid".format(hostname))
            return
        if hostname == self.hostname_cache:
            return

        syslog.syslog(syslog.LOG_INFO, "Get all running containers")
        cmd = 'docker ps --format "{{.Names}}"'
        try:
            containers = subprocess.check_output(cmd, shell=True).split("\n")[:-1]
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                          .format(err.cmd, err.returncode, err.output))

        for name in containers:
            script = '/usr/bin/{}.sh'.format(name)
            exists = os.path.isfile(script)
            if not exists:
                syslog.syslog(syslog.LOG_ERR, "Can't find control script for {}".format(name))
                continue

            cmd = "{} updateHostName {}".format(script, hostname)
            try:
                subprocess.check_call(cmd, shell=True)
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                              .format(err.cmd, err.returncode, err.output))

        self.hostname_cache = hostname

    def mgmt_vrf_handler(self, key, data):
        self.mgmtvrfcfg.handle_mgmt_vrf_cfg(key, data)

    def mgmt_port_handler(self, key, data):
        self.mgmtcfg.handle_mgmt_port_cfg(key, data)

    def mgmt_intf_handler(self, key, data):
        op = "DEL"
        keys = self.config_db.get_keys(CFG_MGMT_INTF_TABLE)
        for it in keys:
            if it[0] == key:
                op = "CREATE"
                break

            it_key = it[0] + "|" + it[1]
            if it_key == key:
                op = "ADD"
                break

        self.mgmtcfg.handle_mgmt_intf_cfg(key, data, op)

    def lpbk_handler(self, key, data):
        key = ConfigDBConnector.deserialize_key(key)
        #Check if delete operation by fetch existing keys
        keys = self.config_db.get_keys('LOOPBACK_INTERFACE')
        if key in keys:
            add = True
        else:
            add = False

        self.iptables.iptables_handler(key, data, add)

    def start(self):
        self.config_db.subscribe('AAA', lambda table, key, data: self.aaa_handler(key, data))
        self.config_db.subscribe('TACPLUS_SERVER', lambda table, key, data: self.tacacs_server_handler(key, data))
        self.config_db.subscribe('TACPLUS', lambda table, key, data: self.tacacs_global_handler(key, data))
        self.config_db.subscribe('RADIUS_SERVER', lambda table, key, data: self.radius_server_handler(key, data))
        self.config_db.subscribe('RADIUS', lambda table, key, data: self.radius_global_handler(key, data))
        self.config_db.subscribe('DEVICE_METADATA', lambda table, key, data: self.hostname_handler(key, data))
        self.config_db.subscribe(CFG_MGMT_VRF, lambda table, key, data: self.mgmt_vrf_handler(key, data))
        self.config_db.subscribe(CFG_MGMT_PORT_TABLE, lambda table, key, data: self.mgmt_port_handler(key, data))
        self.config_db.subscribe(CFG_MGMT_INTF_TABLE, lambda table, key, data: self.mgmt_intf_handler(key, data))
        self.config_db.subscribe('LOOPBACK_INTERFACE', lambda table, key, data: self.lpbk_handler(key, data))
        self.config_db.subscribe('SSH_SERVER_VRF', lambda table, key, data: self.ssh_server_handler(key, data))
        self.config_db.listen()


def main():
    daemon = HostConfigDaemon()
    daemon.start()


if __name__ == "__main__":
    main()

