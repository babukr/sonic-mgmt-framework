#!/usr/bin/env python
#
# Sample pddf_psuutil file 
#
# All the supported PSU SysFS aattributes are 
#- psu_present
#- psu_model_name
#- psu_power_good
#- psu_mfr_id
#- psu_serial_num
#- psu_fan_dir
#- psu_v_out
#- psu_i_out
#- psu_p_out
#- psu_fan1_speed_rpm
#

import os.path
import sys, traceback
sys.path.append('/usr/share/sonic/platform/plugins')
import pddfparse
import json

try:
    from sonic_psu.psu_base import PsuBase
except ImportError as e:
    raise ImportError (str(e) + "- required module not found")


class PsuUtil(PsuBase):
    """PDDF generic PSU util class"""

    def __init__(self):
        PsuBase.__init__(self)
        global pddf_obj
        global plugin_data
        with open(os.path.join(os.path.dirname(os.path.realpath(__file__)) + '/../pddf/pd-plugin.json')) as pd:
            plugin_data = json.load(pd)

        pddf_obj = pddfparse.PddfParse()
        self.platform = pddf_obj.get_platform()

    def get_num_psus(self):
        return int(self.platform['num_psus'])

    def get_psu_status(self, index):
        if index is None:
            return False

        status = 0
        device = "PSU" + "%d"%index
        node = pddf_obj.get_path(device,"psu_power_good")
        if node is None:
            return False
        try:
            with open(node, 'r') as f:
                status = f.read()
        except IOError:
            return False
        vmap = plugin_data['PSU']['psu_power_good']['valmap']

        if status.rstrip('\n') in vmap:
            return vmap[status.rstrip('\n')]
        else:
            return False

    def get_psu_presence(self, index):
        if index is None:
            return False

        status = 0
        device = "PSU" + "%d"%index
        node = pddf_obj.get_path(device,"psu_present")
        if node is None:
            return False
        try:
            with open(node, 'r') as f:
                status = f.read()
        except IOError:
            return False
        vmap = plugin_data['PSU']['psu_present']['valmap']

        if status.rstrip('\n') in vmap:
            return vmap[status.rstrip('\n')]
        else:
            return False

    def get_powergood_status(self, idx):
        if idx is None:
            return False

        if idx<1 or idx>self.platform['num_psus']:
            print "Invalid index %d\n"%idx
            return False

        device = "PSU"+"%d"%(idx)
        node = pddf_obj.get_path(device, "psu_power_good")
        if node is None:
            return False
        try:
            with open(node, 'r') as power_status:
                status = int(power_status.read())
        except IOError:
            return False

        if status == 0:
            return False
        else:
            return True

    def get_model(self, idx):
        if idx is None:
            return None

        if idx<1 or idx>self.platform['num_psus']:
            print "Invalid index %d\n"%idx
            return None

        device = "PSU"+"%d"%(idx)
        node = pddf_obj.get_path(device, "psu_model_name")
        if node is None:
            return None
        try:
            with open(node, 'r') as f:
                model = f.read()
        except IOError:
            return None

        return model.rstrip('\n')

    def get_mfr_id(self, idx):
        if idx is None:
            return None

        if idx<1 or idx>self.platform['num_psus']:
            print "Invalid index %d\n"%idx
            return None

        device = "PSU"+"%d"%(idx)
        node = pddf_obj.get_path(device, "psu_mfr_id")
        if node is None:
            return None
        try:
            with open(node, 'r') as f:
                mfr = f.read()
        except IOError:
            return None

        return mfr.rstrip('\n')

    def get_serial(self, idx):
        if idx is None:
            return None

        if idx<1 or idx>self.platform['num_psus']:
            print "Invalid index %d\n"%idx
            return None

        device = "PSU"+"%d"%(idx)
        node = pddf_obj.get_path(device, "psu_serial_num")
        if node is None:
            return None
        try:
            with open(node, 'r') as f:
                serial = f.read()
        except IOError:
            return None

        return serial.rstrip('\n')

    def get_direction(self, idx):
        if idx is None:
            return None

        if idx<1 or idx>self.platform['num_psus']:
            print "Invalid index %d\n"%idx
            return None

        device = "PSU"+"%d"%(idx)
        node = pddf_obj.get_path(device, "psu_fan_dir")
        if node is None:
            return None
        try:
            with open(node, 'r') as f:
                direction = f.read()
        except IOError:
            return None

        airflow_dir = direction.rstrip('\n')
        vmap = plugin_data['PSU']['psu_fan_dir']['valmap']

        if airflow_dir in vmap:
            airflow_dir_real = vmap[airflow_dir]
        else:
            airflow_dir_real = airflow_dir
            
        return airflow_dir_real

    def get_output_voltage(self, idx):
        if idx is None:
            return 0.0

        if idx<1 or idx>self.platform['num_psus']:
            print "Invalid index %d\n"%idx
            return 0.0

        device = "PSU"+"%d"%(idx)
        node = pddf_obj.get_path(device, "psu_v_out")
        if node is None:
            return 0.0
        try:
            with open(node, 'r') as f:
                v_out = float(f.read())
        except IOError:
            return 0.0

        # value returned by the psu driver is in mV
        return float(v_out/1000)

    def get_output_current(self, idx):
        if idx is None:
            return 0.0

        if idx<1 or idx>self.platform['num_psus']:
            print "Invalid index %d\n"%idx
            return 0.0

        device = "PSU"+"%d"%(idx)
        node = pddf_obj.get_path(device, "psu_i_out")
        if node is None:
            return 0.0
        try:
            with open(node, 'r') as f:
                i_out = float(f.read())
        except IOError:
            return 0.0
        # value returned by the psudriver is in mA
        return float(i_out/1000)

    def get_output_power(self, idx):
        if idx is None:
            return 0.0

        if idx<1 or idx>self.platform['num_psus']:
            print "Invalid index %d\n"%idx
            return 0.0

        device = "PSU"+"%d"%(idx)
        node = pddf_obj.get_path(device, "psu_p_out")
        if node is None:
            return 0.0
        try:
            with open(node, 'r') as f:
                p_out = float(f.read())
        except IOError:
            return 0.0
        
        # value returned by the psu driver is in micro Watt
        return float(p_out/1000000)

    def get_fan_rpm(self, idx, fan_idx):
        if idx is None or fan_idx is None:
            return 0

        if idx<1 or idx>self.platform['num_psus']:
            print "Invalid index %d\n"%idx
            return 0


        device = "PSU"+"%d"%(idx)
        num_fans = pddf_obj.get_num_psu_fans(device)

        if fan_idx<1 or fan_idx>num_fans:
            print "Invalid PSU-fan index %d\n"%fan_idx
            return 0

        node = pddf_obj.get_path(device, "psu_fan"+str(fan_idx)+"_speed_rpm")
        if node is None:
            return 0
        try:
            with open(node, 'r') as f:
                fan_rpm = int(f.read())
        except IOError:
            return 0

        return fan_rpm


    def dump_sysfs(self):
        return pddf_obj.cli_dump_dsysfs('psu')

#if __name__== "__main__":
    #obj=PsuUtil()
    #print(obj.get_psu_status(1))
    #print(obj.get_psu_status(2))
    #print(obj.get_psu_presence(1))
    #print(obj.get_psu_presence(2))
    #print "END\n"
