diff --git a/common/discover.c b/common/discover.c
index 73eb8a9..91e5e2a 100644
--- a/common/discover.c
+++ b/common/discover.c
@@ -1022,6 +1022,7 @@ discover_interfaces(int state) {
 		/* If there isn't already an interface by this name,
 		   allocate one. */
 		if (tmp == NULL) {
+		        log_info("Ading new interface %s to the interface list", info.name);
 			status = interface_allocate(&tmp, MDL);
 			if (status != ISC_R_SUCCESS) {
 				log_fatal("Error allocating interface %s: %s",
diff --git a/common/socket.c b/common/socket.c
index e8851b4..d72f7ce 100644
--- a/common/socket.c
+++ b/common/socket.c
@@ -87,6 +87,8 @@ static int global_v4_socket = -1;
 static int once = 0;
 #endif /* !defined(SO_BINDTODEVICE) && !defined(USE_FALLBACK) */
 
+char local_vrf[32];
+
 /* Reinitializes the specified interface after an address change.   This
    is not required for packet-filter APIs. */
 
@@ -241,11 +243,29 @@ if_register_socket(struct interface_info *info, int family,
 	}
 
 #if defined(SO_BINDTODEVICE)
-	/* Bind this socket to this interface. */
-	if ((local_family != AF_INET6) && (info->ifp != NULL) &&
-	    setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE,
-			(char *)(info -> ifp), sizeof(*(info -> ifp))) < 0) {
-		log_fatal("setsockopt: SO_BINDTODEVICE: %m");
+	if (strcmp(local_vrf, "") != 0) {
+		if (info->ifp == NULL || local_family == AF_INET6) {
+			/* Bind fallback socket in a non default VRF to the VRF device . */
+			if (setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE,
+				       local_vrf, sizeof(local_vrf)) < 0) {
+				log_fatal("setsockopt: SO_BINDTODEVICE: %m");
+			}
+		}
+		else {
+			/* Bind this socket to this interface. */
+			if (setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE,
+				       (char *)(info -> ifp), sizeof(*(info -> ifp))) < 0) {
+				log_fatal("setsockopt: SO_BINDTODEVICE: %m");
+			}
+		}
+	}
+	else {
+		/* Bind this socket to this interface. */
+		if ((local_family != AF_INET6) && (info->ifp != NULL) &&
+		    setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE,
+			       (char *)(info -> ifp), sizeof(*(info -> ifp))) < 0) {
+			log_fatal("setsockopt: SO_BINDTODEVICE: %m");
+		}
 	}
 #endif
 
@@ -766,6 +786,8 @@ ssize_t send_packet6(struct interface_info *interface,
 	struct in6_pktinfo *pktinfo;
 	struct cmsghdr *cmsg;
 	unsigned int ifindex;
+	struct in6_addr *addr6 = NULL;
+	int count = 0;
 
 	/*
 	 * If necessary allocate space for the control message header.
@@ -797,6 +819,12 @@ ssize_t send_packet6(struct interface_info *interface,
 	if (no_global_v6_socket)
 		dst.sin6_scope_id = ifindex;
 
+	if ((strcmp(local_vrf, "") != 0) &&
+	    (dst.sin6_port == remote_port) &&
+	    (IN6_IS_ADDR_LINKLOCAL(&(dst.sin6_addr)))) {
+		dst.sin6_scope_id = ifindex;
+	}
+
 	/*
 	 * Set the data buffer we're sending. (Using this wacky 
 	 * "scatter-gather" stuff... we only have a single chunk 
@@ -824,7 +852,21 @@ ssize_t send_packet6(struct interface_info *interface,
 	cmsg->cmsg_len = CMSG_LEN(sizeof(*pktinfo));
 	pktinfo = (struct in6_pktinfo *)CMSG_DATA(cmsg);
 	memset(pktinfo, 0, sizeof(*pktinfo));
-	pktinfo->ipi6_ifindex = ifindex;
+	if (strcmp(local_vrf, "") == 0)
+		pktinfo->ipi6_ifindex = ifindex;
+	else {
+		for (count = 0; count < interface->v6address_count; count++) {
+			addr6 = &interface->v6addresses[count];
+			if (!(IN6_IS_ADDR_LINKLOCAL(addr6)))
+				break;
+		}
+
+		if (addr6) {
+			memcpy(&pktinfo->ipi6_addr,
+				addr6,
+				sizeof(pktinfo->ipi6_addr));
+		}
+	}
 
 	result = sendmsg(interface->wfdesc, &m, 0);
 	if (result < 0) {
diff --git a/relay/dhcrelay.c b/relay/dhcrelay.c
index b671d74..31937a6 100644
--- a/relay/dhcrelay.c
+++ b/relay/dhcrelay.c
@@ -106,6 +106,8 @@ enum { forward_and_append,	/* Forward and append our own relay option. */
 u_int16_t local_port;
 u_int16_t remote_port;
 
+extern char local_vrf[32];
+
 /* Relay agent server list. */
 struct server_list {
 	struct server_list *next;
@@ -201,6 +203,7 @@ char *progname;
 "                     [-iu interface0 [ ... -iu interfaceN]\n" \
 "                     [-id interface0 [ ... -id interfaceN]\n" \
 "                     [-U interface]\n" \
+"                     [-v vrf_name]\n" \
 "                     server0 [ ... serverN]\n\n" \
 "       %s -6   [-d] [-q] [-I] [-c <hops>] [-p <port>]\n" \
 "                     [-pf <pid-file>] [--no-pid]\n" \
@@ -208,6 +211,7 @@ char *progname;
 "                     [-s <subscriber-id>]\n" \
 "                     -l lower0 [ ... -l lowerN]\n" \
 "                     -u upper0 [ ... -u upperN]\n" \
+"                     [-v vrf_name]\n" \
 "       lower (client link): [address%%]interface[#index]\n" \
 "       upper (server link): [address%%]interface\n\n" DHCRELAY_OPTION82_USAGE
 #else
@@ -220,6 +224,7 @@ char *progname;
 "                [-iu interface0 [ ... -iu interfaceN]\n" \
 "                [-id interface0 [ ... -id interfaceN]\n" \
 "                [-U interface]\n" \
+"                [-v vrf_name]\n" \
 "                server0 [ ... serverN]\n\n" DHCRELAY_OPTION82_USAGE
 #endif
 
@@ -264,6 +269,32 @@ usage(const char *sfmt, const char *sarg) {
 void dhcp_relay_usr1_signal_handler(int s);
 void dhcp_relay_usr2_signal_handler(int s);
 
+static void update_interfaces(void)
+{
+	struct interface_info *tmp = NULL;
+
+	for (tmp = interfaces; tmp; tmp = tmp -> next) {
+		if (!(tmp -> flags & INTERFACE_RUNNING))
+			tmp -> flags |= INTERFACE_RUNNING;
+		if (!(tmp -> flags & INTERFACE_DOWNSTREAM)){
+			if (local_family == AF_INET)
+				tmp -> flags |= INTERFACE_UPSTREAM;
+		}
+	} /* for (tmp = interfaces; ... */
+}
+
+void rescan_interfaces(void *input)
+{
+	struct timeval tv;
+	log_debug("Rescanning the interfaces");
+	discover_interfaces(DISCOVER_RELAY);
+	update_interfaces();
+
+	tv.tv_sec = cur_time + 10;
+	tv.tv_usec = 0;
+	add_timeout(&tv, rescan_interfaces, 0, 0, 0);
+}
+
 int 
 main(int argc, char **argv) {
 	isc_result_t status;
@@ -278,6 +309,7 @@ main(int argc, char **argv) {
 	struct stream_list *sl = NULL;
 	int local_family_set = 0;
 #endif
+	struct timeval tv;
 
 #ifdef OLD_LOG_NAME
 	progname = "dhcrelay";
@@ -285,6 +317,8 @@ main(int argc, char **argv) {
 	progname = argv[0];
 #endif
 
+	strcpy(local_vrf, "");
+
 	/* Make sure that file descriptors 0(stdin), 1,(stdout), and
 	   2(stderr) are open. To do this, we assume that when we
 	   open a file the lowest available file descriptor is used. */
@@ -531,6 +565,10 @@ main(int argc, char **argv) {
 				usage(use_noarg, argv[i-1]);
 			dhcrelay_sub_id = argv[i];
 #endif
+		} else if (!strcmp(argv[i], "-v")) {
+			if (++i == argc)
+				usage(use_noarg, argv[i-1]);
+			strncpy(local_vrf, argv[i], 32);
 		} else if (!strcmp(argv[i], "-pf")) {
 			if (++i == argc)
 				usage(use_noarg, argv[i-1]);
@@ -701,6 +739,7 @@ main(int argc, char **argv) {
 
 	/* Discover all the network interfaces. */
 	discover_interfaces(DISCOVER_RELAY);
+	update_interfaces();
 
 #ifdef DHCPv6
 	if (local_family == AF_INET6)
@@ -766,6 +805,12 @@ main(int argc, char **argv) {
 	/* Using SIGUSR2(user defined signal) to clear the statistics */
 	signal(SIGUSR2, dhcp_relay_usr2_signal_handler);
 
+	/* Periodically scan the interfaces for any interfaces to be excluded or included
+	 * in the list of UPSTREAM interfaces */
+	tv.tv_sec = cur_time + 10;
+	tv.tv_usec = 0;
+	add_timeout(&tv, rescan_interfaces, 0, 0, 0);
+
 	/* Start dispatching packets and timeouts... */
 	dispatch();
 
